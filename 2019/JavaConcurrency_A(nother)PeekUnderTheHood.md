# Java Concurrency, A(nother) Peek under the Hood
TWJUG x Oracle Groundbreakers 2019
### Speaker: David Buck   
2019/10/26


## Avoiding [Heisenbugs](https://en.wikipedia.org/wiki/Heisenbug)
* Java Memory Model
* synchronized keyword
* java.util.concurrent

## Memory Model
* Definition 1
    * Specification that explains when we can guarantee that a written value may be read correctly
* Definition 2
    * Clarify what multithreaded behavior developers may depend on
    * Limits what types of optimizations the runtime may do
* TBD
    
### Memory Ordering
* TBD
### Out of Order Execution
* TBD
### Cpu Differences
* TBD
### Memory Barriers(Fences)
 * Read memory barrier
 * Write memory barrier
 * Memory barriers types
    * store-store
    * store-load
    * load-store
    * load-load
### Compiler barriers
* TBD

### No single "correct" timeline
* Special Relativity 
	* Observed order of evens depends on frame of reference
* Multithreaded Code
	* Observed order of evens depends on thread

### Happened-before (happens-before) Relationship
* [TBD](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5)

### Problems with the Original JVM
* `volatile` does not establish a Happened-before relationship
* `final` values can change
* Many important runtime optimization were not allowed

#### synchronized
```
boolean ready = false;

synchronized void hoge4(){
    data = 42;
    ready = true;
}

synchronized void hoge3(){
    while(!ready){};
    assert data == 42;
}  
```
* synchronized keyword keeps the happened-before relationship
* synchronized keyword give us the guarantee that stuff happens in a synchronized method could be viewed by another synchronized method
* Warning: If hoge3 is executed first, the above code will deadlock

### Modern JMM Keywords
* synchronized
    * mutual exclusion
    * happened-before
* volatile
    * visibility
    * `happened-before`
* `final`
    * `immutability`
    
#### JSR-133 volatile
```
volatile boolean ready = false;

void hoge4(){
    data = 42; 
    ready = true; //volatile supports the happened-before relationship, so this line of code will be executed after [data = 42;]. 
}

synchronized void hoge3(){
    while(!ready){};
    assert data == 42; //volatile supports the happened-before relationship, so this line of code will be executed after "ready" becomes to true.
} 
```
* ~~Warning: If hoge3 is executed first, the aboce code will deadlock~~
* [volatile v.s. synchronization](https://github.com/EddieChoCho/tech_notes/blob/master/Java/Concurrency.md#volatile-vs-synchronization)

#### volatile != atomic
```
volatile int id = 0;
int incID(){
    return id++;
    /**
    * reg = [id]
    * reg++
    * [id] = reg
    **/
}

```
### 64-bit updates are not guaranteed atomic
* Reads and Writes to long and double values may not happen atomically
* Possible to read a mix of two different writes

### [Happened-before](https://en.wikipedia.org/wiki/Happened-before)
* In Java specifically, a happens-before relationship is a guarantee that memory written to by statement A is visible to statement B, that is, that statement A completes its write before statement B starts its read.
* Monitor (acquisition/release)
* Volatile (read/write)
* final "freeze" (constructor)
* [JNI](https://en.wikipedia.org/wiki/Java_Native_Interface)
    * System.out.println ()
    * Input/Output
* thread start()/join()
* operations on j.u.concurrent collections
* TBD 

### Var Handles 
* Lower-level than volatile/final
* Allows a value to be volatile only when we want it to be
* Explicate fence and acquire/release semantics
* Added in JDK 9 to replace several use cases previously only supported with sun.misc.Unsafe

## Tangent2: HSDIS(HotSpot Disassembler)
* Lets us see code generated by JIT
* Requires a disassembler plugin
    * GNU binutils-based plugin
    * base-hsdis
* Command line options
    * +PrintAssembly
    * +CompileCommand=print, *MyClass.myMethod
 
## ARM Assembly Crash Course
* Op Target Source
```
MOV r02 #42
r02 = 42
```
* Exception: STR Source Target
* LDx, Loads data from memory to a register
```
ldr r03, [r06]
r03 = *r06
```
* CMP/BEQ, Compare and branch if equal
```
cmp r0, #0
beq 0x74178d08
if (r0 == 0) goto 0x74178d08
```
* DMB, Data Memory Barrier
```
dmb st
dmb sy
```
## Safe Points
* Methods proactively poll
* JVM makes page unreadable to stop the world
```
movm        ip, #45056  ;   0xb000
movt        ip, #30461  ;   0x76fd
ldr         ip, [ip]    ;   (poll_return)
```

### Long Value Issue Example
```
static long val = 0;
public static void main(String[] args){
    new Thread(() -> {while(true) val = -1L;}).start();
    new Thread(() -> {while(true) val =  0L;}).start();
    while(true){
        long temp = val;
        if(temp != -1 && temp != 0){
            System.out.println("temp (DEC): " + temp);
            System.out.println("temp (BIN): " + Long.toBinaryString(temp));
            System.exit(-1);
        }
    }
}
```
* Solution: static `volatile` long val = 0;
* You could get atomicity (for simple assignments and returns) if you use the volatile keyword when defining a long or double variable
### Object Initialization Issue Example
```
public class ObjInit {
    static ObjInit globalRef = new ObjInit();
    long number;
    public ObjInit(){
        number = 42;
    }

    public static void main(String[] args){
        new Thread(() -> {
            while(true) {
                long temp = globalRef.number;
                if(temp != 42){
                    System.out.println(temp);
                    System.exit(-1);
                }
            }
        }).start();
        new Thread(() -> {while(true) globalRef = new ObjInit();}).start();
}}
```
* Since another thread might read the number field before the object's constructor is finished. The condition of checking "if(temp != 42)" might be satisfied.
* If we add the `final` keyword to the number field, then we could keep the happened-before relationship, 
and the reader method will be guaranteed to see the properly initialized value of "number". 
### Loop Issue Example
```
public class Loop extends Thread {
    static boolean done = false;
    public static void main(String[] args){
        Thread childThread = new Loop();
        childThread.start();
        System.out.println("Starting loop");
        spinWait();
        System.out.println("Exited loop");
    }
    
    private static void spinWait(){
        while(!done);
    }
    
    public void run(){
        try{
            Thread.sleep(5 * 1000);
        } catch(Exception e) {}
        done = true;
    }
}
```
* Since the field "done" do not have the `volatile` keyword, JVM will only read it once and assume it will not be change.
* To fix the code, we need to add the `volatile` keyword to the field "done". 
If we declare "done" to be volatile, as soon as a write occurs for that field, all reads will see the change. 
* Server compiler works differently from client compiler
* TODO: check bytecode
## Avoid low-level API
| Abstract  |                          |
| ----------|------------------------- |
|    /\     |java.util.concurrent      |
|    []     |synchronized              |
|    []     |       wait()/notify()    |
|    []     |volatile/final            |
|    \\/    |   Var handles            |
| Low-level |                          | 

## Testing
* As close to production environment as possible
    * Same hardware
    * Same JRE(including version)
    * Same settings
* As much variety as possible
	* Various hardware
	* Various JREs(including version)
	* Various setting

## Summary
* Avoid low-level APIs
* Code against the standard, not the implementation
* Testing is always indispensable
* Must read Java Concurrency in Practice(JCiP) 


## Further Readings
* [Java Concurrency, A(nother) Peek under the Hood (Youtube)](https://youtu.be/s-b1HxY1DC0)
* [Java Language Specification: Chapter 17. Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html)
* [Java Concurrency in Practice](https://www.tenlong.com.tw/products/9780321349606)