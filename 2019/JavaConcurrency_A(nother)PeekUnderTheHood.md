# Java Concurrency, A(nother) Peek under the Hood
TWJUG x Oracle Groundbreakers 2019
### Speaker: David Buck   
2019/10/26


## Avoiding [Heisenbugs](https://en.wikipedia.org/wiki/Heisenbug)
* Java Memory Model
* synchronized keyword
* java.util.concurrent

## Memory Model
* Definition 1
    * Specification that explains when we can guarantee that a written value may be read correctly
* Definition 2
    * Clarify what multithreaded behavior developers may depend on
    * Limits what types of optimizations the runtime may do
    
### Memory Ordering
* TBD
### Out of Order Execution
* TBD
### Cpu Differences
* TBD
### Memory Barriers(Fences)
 * Read memory barrier
 * Write memory barrier
 * Memory barriers types
    * store-store
    * store-load
    * load-store
    * load-load
### Compiler barriers
* TBD

### No single "correct" timeline
* Special Relativity 
	* Observed order of evens depends on frame of reference
* Multithreaded Code
	* Observed order of evens depends on thread

### Happened-before (happens-before) Relationship
* [TBD](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5)

### Problems with the Original JVM
* `volatile` does not establish a Happened-before relationship
* `final` values can change
* Many important runtime optimization were not allowed

#### synchronized
```
boolean ready = false;

synchronized void hoge4(){
    data = 42;
    ready = true;
}

synchronized void hoge3(){
    while(!ready){};
    assert data == 42;
}  
```
* synchronized keyword give us the guarantee that stuff happens in a synchronized method could be viewed by another synchronized method
* Warning: If hoge3 is executed first, the above**** code will deadlock

### Modern JMM Keywords
* synchronized
    * mutual exclusion
    * happened-before
* volatile
    * visibility
    * `happened-before`
* `final`
    * `immutability`
    
#### JSR-133 volatile
```
volatile boolean ready = false;

void hoge4(){
    data = 42; 
    ready = true; //volatile supports the happened-before relation ship, so this line of code will be executed after [data = 42;]. 
}

synchronized void hoge3(){
    while(!ready){};
    assert data == 42;//volatile supports the happened-before relation ship, so this line of code will be executed after "ready" becomes to true.
} 
```
* ~~Warning: If hoge3 is executed first, the aboce code will deadlock~~

#### volatile != atomic
```
volatile int id = 0;
int incID(){
    return id++;
    /**
    * reg = [id]
    * reg++
    * [id] = reg
    **/
}

```
### 64-bit updates are not guaranteed atomic
* Reads and Writes to long and double values may not happen atomically
* Possible to read a mix of two different writes

### Happened-before
* Monitor (acquisition/release)
* Volatile (read/write)
* final "freeze" (constructor)
* JNI
    * System.out.println ()
    * Input/Output
* thread start()/join()
* operations on j.u.concurrent collections

### Var Handles 
* Lower-level than volatile/final
* Allows a value to be volatile only when we want it to be
* Explicate fence and acquire/release semantics
* Added in JDK 9 to replace several use cases previously only supported with sun.misc.Unsafe

## Tangent2: HSDIS(HotSpot Disassembler)
* Lets us see code generated by JIT
* Requires a disassembler plugin
    * GNU binutils-based plugin
    * base-hsdis
* Command line options
    * +PrintAssembly
    * +CompileCommand=print, *MyClass.myMethod
 
## ARM Assembly Crash Course
* Op Target Source
```
MOV r02 #42
r02 = 42
```
* Exception: STR Source Target
* LDx, Loads data from memory to a register
```
ldr r03, [r06]
r03 = *r06
```
* CMP/BEQ, Compare and branch if equal
```
cmp r0, #0
beq 0x74178d08
if (r0 == 0) goto 0x74178d08
```
* DMB, Data Memory Barrier
```
dmb st
dmb sy
```
## Safe Points
* Methods proactively poll
* JVM makes page unreadable to stop the world
```
movm        ip, #45056  ;   0xb000
movt        ip, #30461  ;   0x76fd
ldr         ip, [ip]    ;   (poll_return)
```

### Long Value Issue Example
* TBD (solution: volatile)
### Object Initialization Issue Example
* TBD (solution: final)
### Loop Issue Example
* TBD (solution: volatile)
* Server compiler works differently from client compiler

## Avoid low-level API
| Abstract  |                          |
| ----------|------------------------- |
|    /\     |java.util.concurrent      |
|    []     |synchronized              |
|    []     |       wait()/notify()    |
|    []     |volatile/final            |
|    \\/    |   Var handles            |
| Low-level |                          | 

## Testing
* As close to production environment as possible
    * Same hardware
    * Same JRE(including version)
    * Same settings

## Summary
* Avoid low-level APIs
* Code against the standard, not the implementation
* Testing is always indispensible
* Must read Java Concurrency in Practice(JCiP) 


## Further Readings
* [Java Language Specification: Chapter 17. Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html)
* [Java Concurrency in Practice](https://www.tenlong.com.tw/products/9780321349606)